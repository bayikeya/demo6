<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>複数画像切替付きスポット案内（IMU融合 + Kalman + Road Snap）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; text-align: center; }
    #camera { width: 100vw; height: 100vh; object-fit: cover; position: absolute; top: 0; left: 0; z-index: -1; }
    #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; z-index: 2; white-space: pre-wrap; font-size: 14px; text-align: left; }
    #image { position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%); width: 300px; height: 300px; object-fit: contain; display: none; z-index: 2; background: black; }
    .btn { position: absolute; left: 50%; transform: translateX(-50%); background-color: #007BFF; color: white; border: none; padding: 10px 20px; font-size: 14px; border-radius: 8px; cursor: pointer; z-index: 3; display: none; }
    #patternBtn { bottom: 70px; }
    #nextBtn { bottom: 20px; }
    .img-nav { position: absolute; bottom: 260px; z-index: 3; font-size: 20px; background: rgba(0,0,0,0.5); color: white; border: none; padding: 5px 15px; cursor: pointer; border-radius: 6px; }
    #prevBtn { left: 10%; }
    #nextImgBtn { right: 10%; }

    /* 起動時の全画面スタートオーバーレイ */
    #startupOverlay {
      position: absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.8));
      z-index: 10;
      flex-direction: column;
      gap: 16px;
    }
    #startBtn {
      background: #d9534f;
      color: white;
      border: none;
      padding: 18px 32px;
      font-size: 20px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,0.4);
    }
    #startSub {
      color: #ddd;
      font-size: 14px;
      max-width: 80%;
      text-align: center;
    }
  </style>
</head>
<body>

<video id="camera" autoplay playsinline muted></video>
<div id="info">位置情報取得中...</div>
<img id="image" src="" alt="スポット画像" />
<button class="btn" id="patternBtn" onclick="switchPattern()">English</button>
<button class="btn" id="nextBtn" onclick="goToNextSpot()">このスポットは完了</button>
<button class="img-nav" id="prevBtn" onclick="showPrevImage()" style="display:none;">←</button>
<button class="img-nav" id="nextImgBtn" onclick="showNextImage()" style="display:none;">→</button>
<audio id="audio" src=""></audio>

<!-- 起動時ユーザー操作オーバーレイ -->
<div id="startupOverlay" aria-hidden="false">
  <button id="startBtn">避難開始</button>
  <div id="startSub">画面をタップしてセンサーと音声再生を許可します。タップすると案内音声が自動再生されます。</div>
</div>

<!-- turf.js -->
<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

<script>
/* ---------------- データ: スポット ---------------- */
const spots = [
  { name: "13号館前", lat: 35.69302425885399, lon: 140.0508424409975, radius: 0, images: ["image0.jpeg", "image1.jpeg"], audio: { A: "spot1.ja.mp3", B: "spot1.en.mp3", C: "spot1.ch.mp3" } },
  { name: "曲がり角右", lat:35.69283599175495,  lon:140.05092001888113, radius: 10, images: ["image3.jpeg", "image11.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
  { name: "曲がり角右１", lat: 35.69286877921128,   lon: 140.05030279528978, radius: 10, images: ["image4.jpeg", "image13.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
  { name: "曲がり角右２", lat: 35.69334894066289,  lon: 140.05033682451656, radius: 10, images: ["image5.jpeg", "image14.jpeg"], audio: { A: "spot5,6.ja.mp3", B: "spot5,6.en.mp3", C: "spot5,6.ch.mp3" } },
  { name: "曲がり角右３", lat: 35.69331981781718,  lon: 140.05102244720183, radius: 10, images: ["image6.jpeg", "image15.jpeg"], audio: { A: "spot5,6.ja.mp3", B: "spot5,6.en.mp3", C: "spot5,6.ch.mp3" } },
  { name: "目的地", lat: 35.693014464267506,  lon: 140.0509410980045, radius: 10, images: ["image7.jpeg", "image16.jpeg"], audio: { A: "spot7,8.ja.mp3", B: "spot7,8.en.mp3", C: "spot7,8.ch.mp3" } }
];

let currentIndex = 0;
let hasEnteredSpot = false;
let currentSpot = null;
let currentPattern = "A";
let imageIndex = 0;

const camera = document.getElementById("camera");
const info = document.getElementById("info");
const image = document.getElementById("image");
const nextBtn = document.getElementById("nextBtn");
const patternBtn = document.getElementById("patternBtn");
const audio = document.getElementById("audio");
const prevBtn = document.getElementById("prevBtn");
const nextImgBtn = document.getElementById("nextImgBtn");

const startupOverlay = document.getElementById("startupOverlay");
const startBtn = document.getElementById("startBtn");

/* ---------------- カメラ起動 ---------------- */
navigator.mediaDevices?.getUserMedia({ video: { facingMode: "environment" }, audio: false })
  .then(stream => camera.srcObject = stream)
  .catch(err => console.log("カメラへのアクセスに失敗しました:", err));

/* ---------------- Kalman フィルタ (1D) - 常時有効 ---------------- */
class SimpleKalman {
  constructor(R = 0.00002, Q = 0.000001) {
    this.R = R; this.Q = Q;
    this.x = NaN; this.P = 1;
  }
  filter(z) {
    if (isNaN(this.x)) { this.x = z; this.P = 1; return this.x; }
    this.P = this.P + this.Q;
    const K = this.P / (this.P + this.R);
    this.x = this.x + K * (z - this.x);
    this.P = (1 - K) * this.P;
    return this.x;
  }
  reset() { this.x = NaN; this.P = 1; }
}
const kalmanLat = new SimpleKalman();
const kalmanLon = new SimpleKalman();

/* ---------------- 距離計算（haversine） ---------------- */
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/* ---------------- GeoJSON 道路データ読み込み & スナップ（閾値固定 10m） ---------------- */
let roadsGeoJSON = null;
const roadsUrl = "demo.geojson";
const SNAP_THRESHOLD_METERS = 10;

async function loadRoads() {
  try {
    const res = await fetch(roadsUrl);
    if (!res.ok) throw new Error("HTTP " + res.status);
    demoGeoJSON = await res.json();
    console.log("roads.geojson 読み込み完了:", (demoGeoJSON.features?.length || 0), "features");
  } catch (e) {
    demoGeoJSON = null;
    console.warn("roads.geojson の読み込みに失敗しました:", e);
  }
}
loadRoads();

function snapToRoad(lat, lon, thresholdMeters = SNAP_THRESHOLD_METERS) {
  if (!roadsGeoJSON) return { snapped: false, lat, lon, distanceToRoad: Infinity };
  const pt = turf.point([lon, lat]);
  let best = { distance: Infinity, point: null };
  for (const feature of roadsGeoJSON.features) {
    if (!feature.geometry) continue;
    try {
      const snapped = turf.nearestPointOnLine(feature, pt, { units: "meters" });
      const d = snapped.properties?.dist ?? snapped.properties?.distance ?? (turf.distance(pt, snapped, { units: "kilometers" }) * 1000);
      if (typeof d === "number" && d < best.distance) {
        best.distance = d; best.point = snapped;
      }
    } catch (e) {
      console.warn("nearestPointOnLine failed for feature:", e);
    }
  }
  if (best.point && best.distance <= thresholdMeters) {
    const [snLon, snLat] = best.point.geometry.coordinates;
    return { snapped: true, lat: snLat, lon: snLon, distanceToRoad: best.distance };
  } else {
    return { snapped: false, lat, lon, distanceToRoad: best.distance };
  }
}

/* ---------------- IMUベースのデッドレコニング（センサー融合、自動はせず、ボタンで開始） ---------------- */
let imuEnabled = false;
let lastImuTs = null;
let headingDeg = null; // 0..360
let velocityN = 0, velocityE = 0; // m/s
let odom = { north: 0, east: 0 };
let lastRef = null;
const MAX_IMU_INTEGRATION_TIME = 30000; // ms

function enableIMU() {
  if (imuEnabled) return Promise.resolve();
  // iOS の requestPermission はユーザーアクション（ここでは startBtn のクリック）から呼ぶ必要があるため、
  // この関数はスタートボタンのハンドラ内から呼びます。
  const permissions = [];
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    permissions.push(DeviceMotionEvent.requestPermission());
  }
  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
    permissions.push(DeviceOrientationEvent.requestPermission());
  }

  return Promise.all(permissions.map(p => p.catch(e => e))).then(results => {
    // いずれにせよイベントリスナは登録
    window.addEventListener("devicemotion", onDeviceMotion, { passive: true });
    window.addEventListener("deviceorientation", onDeviceOrientation, { passive: true });
    imuEnabled = true;
    console.log("IMU enabled, permission results:", results);
  }).catch(e => {
    window.addEventListener("devicemotion", onDeviceMotion, { passive: true });
    window.addEventListener("deviceorientation", onDeviceOrientation, { passive: true });
    imuEnabled = true;
    console.warn("IMU enable error, listeners registered anyway:", e);
  });
}

// DeviceOrientation: ヘディング取得
function onDeviceOrientation(e) {
  if (typeof e.webkitCompassHeading === "number") {
    headingDeg = e.webkitCompassHeading;
  } else if (typeof e.alpha === "number") {
    headingDeg = e.alpha;
  } else {
    headingDeg = null;
  }
}

// DeviceMotion: 単純化した前方軸のみを用いた積分
function onDeviceMotion(e) {
  const now = Date.now();
  if (!lastImuTs) lastImuTs = now;
  const dt = Math.min(0.2, (now - lastImuTs) / 1000);
  lastImuTs = now;

  const acc = e.acceleration && (e.acceleration.x !== null || e.acceleration.y !== null) ? e.acceleration : e.accelerationIncludingGravity;
  if (!acc) return;

  const forwardAccel = -(acc.y || 0);

  const h = (typeof headingDeg === "number") ? (headingDeg * Math.PI / 180) : null;

  let aN = 0, aE = 0;
  if (h !== null) {
    aN = forwardAccel * Math.cos(h);
    aE = forwardAccel * Math.sin(h);
  } else {
    aN = forwardAccel;
    aE = 0;
  }

  velocityN += aN * dt;
  velocityE += aE * dt;

  const dispN = velocityN * dt + 0.5 * aN * dt * dt;
  const dispE = velocityE * dt + 0.5 * aE * dt * dt;

  odom.north += dispN;
  odom.east += dispE;

  if (lastRef && (Date.now() - lastRef.ts) > MAX_IMU_INTEGRATION_TIME) {
    velocityN = 0; velocityE = 0;
    odom.north = 0; odom.east = 0;
    lastImuTs = null;
  }
}

/* ---------------- 位置情報（GPS）とセンサー融合のロジック ---------------- */
let lastGps = null;
const metersPerDegLat = 111320;
function metersPerDegLonAtLat(lat) { return 111320 * Math.cos(lat * Math.PI / 180); }

function onGpsPosition(pos) {
  const rawLat = pos.coords.latitude;
  const rawLon = pos.coords.longitude;
  const accuracy = pos.coords.accuracy || 30;

  if (!lastGps) {
    lastGps = { lat: rawLat, lon: rawLon, ts: Date.now() };
    odom.north = 0; odom.east = 0;
    velocityN = 0; velocityE = 0;
    lastRef = { lat: lastGps.lat, lon: lastGps.lon, ts: lastGps.ts };
    // Kalman に最初の値を食わせる
    const kLat = kalmanLat.filter(lastRef.lat);
    const kLon = kalmanLon.filter(lastRef.lon);
    // snap
    const snapRes = snapToRoad(kLat, kLon, SNAP_THRESHOLD_METERS);
    const usedLat = snapRes.snapped ? snapRes.lat : kLat;
    const usedLon = snapRes.snapped ? snapRes.lon : kLon;
    checkProximity(usedLat, usedLon);
    return;
  }

  // 1) 予測位置 = lastRef + odom
  const mpdLon = metersPerDegLonAtLat(lastRef.lat);
  const predLat = lastRef.lat + (odom.north / metersPerDegLat);
  const predLon = lastRef.lon + (odom.east / mpdLon);

  // 2) 融合係数 beta: GPSの精度が悪ければIMUにより重みを置く
  const beta = Math.min(0.9, (accuracy / 100)); // 0..0.9
  const fusedLat = rawLat * (1 - beta) + predLat * beta;
  const fusedLon = rawLon * (1 - beta) + predLon * beta;

  // 3) リセット
  lastGps = { lat: fusedLat, lon: fusedLon, ts: Date.now() };
  lastRef = { lat: fusedLat, lon: fusedLon, ts: lastGps.ts };
  odom.north = 0; odom.east = 0;
  velocityN = 0; velocityE = 0;

  // 4) Kalman（常時有効）
  const usedLatKal = kalmanLat.filter(fusedLat);
  const usedLonKal = kalmanLon.filter(fusedLon);

  // 5) snap（常時有効、閾値 10m）
  const snapRes = snapToRoad(usedLatKal, usedLonKal, SNAP_THRESHOLD_METERS);
  const usedLat = snapRes.snapped ? snapRes.lat : usedLatKal;
  const usedLon = snapRes.snapped ? snapRes.lon : usedLonKal;

  // 6) 判定
  checkProximity(usedLat, usedLon);
}

/* ---------------- スポット判定（シンプル表示） ---------------- */
function checkProximity(lat, lon) {
  if (currentIndex >= spots.length) {
    info.innerText = "すべてのスポットを通過しました。";
    hideAllUI();
    return;
  }
  const spot = spots[currentIndex];
  const distance = getDistance(lat, lon, spot.lat, spot.lon);
  const range = spot.radius || 10;

  info.innerText =
    `現在地: 緯度 ${lat.toFixed(6)}, 経度 ${lon.toFixed(6)}\n` +
    `次のスポット: ${spot.name}（${currentIndex + 1} / ${spots.length}）\n` +
    `残り距離: ${distance.toFixed(1)}m`;

  if (currentIndex >= 1 && !hasEnteredSpot && distance < range) {
    showSpot(spot);
  }
}

/* ---------------- スポット表示 / 画像 / 音声 ---------------- */
function showSpot(spot) {
  currentSpot = spot;
  hasEnteredSpot = true;
  imageIndex = 0;

  audio.src = spot.audio[currentPattern];
  image.src = spot.images[imageIndex];
  image.style.display = "block";
  nextBtn.style.display = "block";
  patternBtn.style.display = "block";
  prevBtn.style.display = spot.images.length > 1 ? "block" : "none";
  nextImgBtn.style.display = spot.images.length > 1 ? "block" : "none";

  // audio.play はスタートボタンのユーザー操作で解除済みのはずなので試みる
  audio.loop = true;
  audio.play().catch(e => console.log("自動再生に失敗:", e));
}

function switchPattern() {
  const patterns = ["A", "B", "C"];
  const index = patterns.indexOf(currentPattern);
  currentPattern = patterns[(index + 1) % patterns.length];
  updatePatternButtonText();
  if (currentSpot) {
    audio.pause();
    audio.src = currentSpot.audio[currentPattern];
    audio.play().catch(e => console.log("自動再生に失敗:", e));
  }
}
function updatePatternButtonText() {
  let label = "";
  switch (currentPattern) {
    case "A": label = "English"; break;
    case "B": label = "中文"; break;
    case "C": label = "日本語"; break;
  }
  patternBtn.innerText = label;
}
function showPrevImage() {
  if (!currentSpot) return;
  imageIndex = (imageIndex - 1 + currentSpot.images.length) % currentSpot.images.length;
  image.src = currentSpot.images[imageIndex];
}
function showNextImage() {
  if (!currentSpot) return;
  imageIndex = (imageIndex + 1) % currentSpot.images.length;
  image.src = currentSpot.images[imageIndex];
}
function goToNextSpot() {
  audio.pause();
  currentIndex++;
  hasEnteredSpot = false;
  currentSpot = null;
  hideAllUI();
}
function hideAllUI() {
  image.style.display = "none";
  nextBtn.style.display = "none";
  patternBtn.style.display = "none";
  prevBtn.style.display = "none";
  nextImgBtn.style.display = "none";
}

/* ---------------- 位置情報取得: watchPosition（Kalman + snap + IMU融合） ---------------- */
if ("geolocation" in navigator) {
  const options = { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 };
  navigator.geolocation.watchPosition(
    pos => onGpsPosition(pos),
    err => info.innerText = "位置情報の取得に失敗しました: " + err.message,
    options
  );
} else {
  info.innerText = "このブラウザは位置情報に対応していません。";
}

/* ---------------- 起動時のスタートボタン処理 ---------------- */
let userStarted = false;
startBtn.addEventListener("click", async () => {
  if (userStarted) return;
  userStarted = true;

  // Hide overlay immediately
  startupOverlay.style.display = "none";
  startupOverlay.setAttribute("aria-hidden", "true");

  // Attempt to unlock AudioContext to maximize autoplay success
  try {
    // Some browsers require creating/resuming AudioContext in user gesture
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (AudioCtx) {
      const ctx = new AudioCtx();
      if (ctx.state === "suspended") {
        await ctx.resume().catch(e => { /* ignore */ });
      }
    }
  } catch (e) {
    console.warn("AudioContext unlock failed:", e);
  }

  // Enable IMU (calls requestPermission on iOS if available) - must be called in user gesture
  try {
    await enableIMU();
  } catch (e) {
    console.warn("enableIMU failed on start:", e);
  }

  // Show first spot and attempt audio autoplay (allowed because this is user gesture)
  try {
    showSpot(spots[0]);
  } catch (e) {
    console.warn("showSpot(spots[0]) failed:", e);
  }
});

/* ---------------- 起動時の最小セットアップ ---------------- */
window.addEventListener("load", () => {
  updatePatternButtonText();
  // Do NOT auto-enable IMU or auto-play audio here: we wait for user to press "避難開始".
  // roads.geojson was loaded earlier by loadRoads().
});
</script>

</body>
</html>
