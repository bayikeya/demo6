<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>複数画像切替付きスポット案内（IMU融合 + Kalman + Road Snap） - 改良版</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif; text-align: center; }
    #camera { width: 100vw; height: 100vh; object-fit: cover; position: absolute; top: 0; left: 0; z-index: -1; }
    #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px; z-index: 2; white-space: pre-wrap; font-size: 14px; text-align: left; }
    #image { position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%); width: 300px; height: 300px; object-fit: contain; display: none; z-index: 2; background: black; }
    .btn { position: absolute; left: 50%; transform: translateX(-50%); background-color: #007BFF; color: white; border: none; padding: 10px 20px; font-size: 14px; border-radius: 8px; cursor: pointer; z-index: 3; display: none; }
    #patternBtn { bottom: 70px; }
    #nextBtn { bottom: 20px; }
    .img-nav { position: absolute; bottom: 260px; z-index: 3; font-size: 20px; background: rgba(0,0,0,0.5); color: white; border: none; padding: 5px 15px; cursor: pointer; border-radius: 6px; }
    #prevBtn { left: 10%; }
    #nextImgBtn { right: 10%; }
    #startupOverlay {
      position: absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.8));
      z-index: 10;
      flex-direction: column;
      gap: 16px;
    }
    #startBtn {
      background: #d9534f;
      color: white;
      border: none;
      padding: 18px 32px;
      font-size: 20px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0,0,0,0.4);
    }
    #startSub { color: #ddd; font-size: 14px; max-width: 80%; text-align: center; }
  </style>
</head>
<body>

<video id="camera" autoplay playsinline muted></video>
<div id="info">位置情報取得中...</div>
<img id="image" src="" alt="スポット画像" />
<button class="btn" id="patternBtn" onclick="switchPattern()">English</button>
<button class="btn" id="nextBtn" onclick="goToNextSpot()">このスポットは完了</button>
<button class="img-nav" id="prevBtn" onclick="showPrevImage()" style="display:none;">←</button>
<button class="img-nav" id="nextImgBtn" onclick="showNextImage()" style="display:none;">→</button>
<audio id="audio" src=""></audio>

<div id="startupOverlay" aria-hidden="false">
  <button id="startBtn">避難開始</button>
  <div id="startSub">画面をタップしてセンサーと音声再生を許可します。タップすると案内音声が自動再生されます。</div>
</div>

<script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

<script>
/* ---------------- データ: スポット（例） ---------------- */
const spots = [
  { name: "13号館前", lat: 35.69302425885399, lon: 140.0508424409975, radius: 0, images: ["image0.jpeg", "image1.jpeg"], audio: { A: "spot1.ja.mp3", B: "spot1.en.mp3", C: "spot1.ch.mp3" } },
  { name: "曲がり角右", lat:35.69283599175495,  lon:140.05092001888113, radius: 10, images: ["image3.jpeg", "image11.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
  { name: "曲がり角右１", lat: 35.69286877921128,   lon: 140.05030279528978, radius: 10, images: ["image4.jpeg", "image13.jpeg"], audio: { A: "spot3,4.ja.mp3", B: "spot3,4.en.mp3", C: "spot3,4.ch.mp3" } },
  { name: "曲がり角右２", lat: 35.69334894066289,  lon: 140.05033682451656, radius: 10, images: ["image5.jpeg", "image14.jpeg"], audio: { A: "spot5,6.ja.mp3", B: "spot5,6.en.mp3", C: "spot5,6.ch.mp3" } },
  { name: "曲がり角右３", lat: 35.69331981781718,  lon: 140.05102244720183, radius: 10, images: ["image6.jpeg", "image15.jpeg"], audio: { A: "spot5,6.ja.mp3", B: "spot5,6.en.mp3", C: "spot5,6.ch.mp3" } },
  { name: "目的地", lat: 35.693014464267506,  lon: 140.0509410980045, radius: 10, images: ["image7.jpeg", "image16.jpeg"], audio: { A: "spot7,8.ja.mp3", B: "spot7,8.en.mp3", C: "spot7,8.ch.mp3" } }
];

/* ---------------- UI / DOM ---------------- */
let currentIndex = 0, hasEnteredSpot = false, currentSpot = null, currentPattern = "A", imageIndex = 0;
const camera = document.getElementById("camera"), info = document.getElementById("info"), image = document.getElementById("image");
const nextBtn = document.getElementById("nextBtn"), patternBtn = document.getElementById("patternBtn");
const prevBtn = document.getElementById("prevBtn"), nextImgBtn = document.getElementById("nextImgBtn");
const audioEl = document.getElementById("audio");
const startupOverlay = document.getElementById("startupOverlay"), startBtn = document.getElementById("startBtn");

/* ---------------- カメラ起動（変わらず） ---------------- */
navigator.mediaDevices?.getUserMedia({ video: { facingMode: "environment" }, audio: false })
  .then(stream => camera.srcObject = stream)
  .catch(err => console.log("カメラへのアクセスに失敗しました:", err));

/* ---------------- 道路データ読み込み ---------------- */
let roadsGeoJSON = null;
const roadsUrl = "demo.geojson";
const SNAP_THRESHOLD_METERS = 10;
async function loadRoads() {
  try {
    const res = await fetch(roadsUrl);
    if (!res.ok) throw new Error("HTTP " + res.status);
    roadsGeoJSON = await res.json();
    console.log("roads.geojson 読み込み完了:", (roadsGeoJSON.features?.length || 0), "features");
  } catch (e) {
    roadsGeoJSON = null;
    console.warn("roads.geojson の読み込みに失敗しました:", e);
  }
}
loadRoads();

function snapToRoad(lat, lon, thresholdMeters) {
  if (!roadsGeoJSON) return { snapped: false, lat, lon, distanceToRoad: Infinity };
  const pt = turf.point([lon, lat]);
  let best = { distance: Infinity, point: null };
  for (const feature of roadsGeoJSON.features) {
    if (!feature.geometry) continue;
    try {
      const snapped = turf.nearestPointOnLine(feature, pt, { units: "meters" });
      const d = snapped.properties?.dist ?? snapped.properties?.distance ?? (turf.distance(pt, snapped, { units: "kilometers" }) * 1000);
      if (typeof d === "number" && d < best.distance) {
        best.distance = d; best.point = snapped;
      }
    } catch (e) {
      console.warn("nearestPointOnLine failed for feature:", e);
    }
  }
  if (best.point && best.distance <= thresholdMeters) {
    const [snLon, snLat] = best.point.geometry.coordinates;
    return { snapped: true, lat: snLat, lon: snLon, distanceToRoad: best.distance };
  } else {
    return { snapped: false, lat, lon, distanceToRoad: best.distance };
  }
}

/* ---------------- 座標変換（緯度経度 ↔ メートル） ---------------- */
let originLat = null, originLon = null;
const metersPerDegLat = 111320;
function metersPerDegLonAtLat(lat) { return 111320 * Math.cos(lat * Math.PI / 180); }
function latLonToLocalMeters(lat, lon) {
  if (originLat === null) {
    originLat = lat; originLon = lon;
  }
  const dy = (lat - originLat) * metersPerDegLat;
  const dx = (lon - originLon) * metersPerDegLonAtLat((lat+originLat)/2);
  return { x: dx, y: dy }; // x: east, y: north
}
function localMetersToLatLon(y, x) {
  // inputs: y:north (m), x:east (m)
  const lat = originLat + (y / metersPerDegLat);
  const lon = originLon + (x / metersPerDegLonAtLat(originLat));
  return { lat, lon };
}

/* ---------------- 4状態カルマンフィルタ（N, E, vN, vE） ---------------- */
class KF4 {
  constructor() {
    this.x = mathZeros(4); // [n, e, vN, vE] in meters/ m/s
    this.P = identity(4, 4, 1e1);
    this.Q = identity(4,4, 0.1); // process noise, tune
    this.lastTs = null;
  }
  predict(ax, ay, dt) {
    if (dt <= 0) return;
    // State transition:
    // n' = n + vN*dt + 0.5*aN*dt^2
    // e' = e + vE*dt + 0.5*aE*dt^2
    // vN' = vN + aN*dt
    // vE' = vE + aE*dt
    const F = [
      [1,0,dt,0],
      [0,1,0,dt],
      [0,0,1,0],
      [0,0,0,1]
    ];
    const Bu = [0.5*ax*dt*dt, 0.5*ay*dt*dt, ax*dt, ay*dt];
    this.x = addVec(matMulVec(F, this.x), Bu);
    // P = F P F^T + Q (simple)
    this.P = addMat(matMul(F, matMul(this.P, transpose(F))), scalarMat(this.Q, dt));
  }
  updatePos(zx, zy, Rpos) {
    // Measurement z = [n, e]
    const H = [
      [1,0,0,0],
      [0,1,0,0]
    ];
    const R = [[Rpos*Rpos, 0],[0, Rpos*Rpos]];
    const y = subVec([zx, zy], matMulVec(H, this.x));
    const S = addMat(matMul(H, matMul(this.P, transpose(H))), R);
    const K = matMul(this.P, matMul(transpose(H), inv2(S)));
    this.x = addVec(this.x, matMulVec(K, y));
    const I = identity(4,4,1);
    this.P = matMul(subMat(I, matMul(K, H)), this.P);
  }
  getState() { return this.x.slice(); }
  resetTo(x0, P0 = null) { this.x = x0.slice(); this.P = P0 ? P0 : identity(4,4,1e1); }
}

/* -------------- 軽量行列ユーティリティ（最小限） -------------- */
function identity(n,m,val=1){ const a=[]; for(let i=0;i<n;i++){a[i]=Array(m).fill(0); a[i][i]=val;} return a; }
function mathZeros(n){ return Array(n).fill(0); }
function scalarMat(mat, s){ return mat.map(row=>row.map(v=>v*s)); }
function matMul(A,B){ const r=A.length, c=B[0].length, mid=A[0].length; const out=[]; for(let i=0;i<r;i++){ out[i]=Array(c).fill(0); for(let k=0;k<mid;k++){ for(let j=0;j<c;j++){ out[i][j]+=A[i][k]*B[k][j]; } } } return out;}
function matMulVec(A,v){ const r=A.length, c=v.length; const out=Array(r).fill(0); for(let i=0;i<r;i++){ for(let j=0;j<c;j++){ out[i]+=A[i][j]*v[j]; } } return out; }
function transpose(A){ return A[0].map((_,i)=>A.map(row=>row[i])); }
function addMat(A,B){ return A.map((row,i)=>row.map((v,j)=>v+(B[i][j]||0))); }
function subMat(A,B){ return A.map((row,i)=>row.map((v,j)=>v-(B[i][j]||0))); }
function addVec(a,b){ return a.map((v,i)=>v+(b[i]||0)); }
function subVec(a,b){ return a.map((v,i)=>v-(b[i]||0)); }
function inv2(M){ // inverse of 2x2 matrix
  const a=M[0][0], b=M[0][1], c=M[1][0], d=M[1][1];
  const det=a*d-b*c; if(Math.abs(det)<1e-9) return [[1e9,0],[0,1e9]];
  const id=1/det; return [[d*id, -b*id],[-c*id, a*id]];
}
function matMulScalar(A,s){ return A.map(r=>r.map(v=>v*s)); }

/* ---------------- 状態とIMU/GPSフュージョン ---------------- */
const kf = new KF4();
let imuEnabled = false, lastImuTs = null, headingDeg = null;
let originSet = false, lastGps = null;
let userStarted = false;
const MAX_IMU_INTEGRATION_TIME = 20000; // ms

function enableIMU() {
  if (imuEnabled) return Promise.resolve();
  const permissions = [];
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") permissions.push(DeviceMotionEvent.requestPermission());
  if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") permissions.push(DeviceOrientationEvent.requestPermission());
  return Promise.all(permissions.map(p=>p.catch(e=>e))).then(()=> {
    window.addEventListener("devicemotion", onDeviceMotion, { passive: true });
    window.addEventListener("deviceorientation", onDeviceOrientation, { passive: true });
    imuEnabled = true;
  }).catch(()=> {
    window.addEventListener("devicemotion", onDeviceMotion, { passive: true });
    window.addEventListener("deviceorientation", onDeviceOrientation, { passive: true });
    imuEnabled = true;
  });
}

function onDeviceOrientation(e){
  if (typeof e.webkitCompassHeading === "number") headingDeg = e.webkitCompassHeading;
  else if (typeof e.alpha === "number") headingDeg = e.alpha;
  else headingDeg = null;
}

let stationaryCounter = 0;
function onDeviceMotion(e){
  const now = Date.now();
  if (!kfsafeTime(now)) { lastImuTs = now; return; }
  if (!lastImuTs) lastImuTs = now;
  let dt = Math.min(0.2, (now - lastImuTs)/1000);
  lastImuTs = now;

  const acc = e.acceleration && (e.acceleration.x !== null || e.acceleration.y !== null) ? e.acceleration : e.accelerationIncludingGravity;
  if (!acc) return;
  // 前方軸としての y を使用（既存の簡易的扱い）
  const forwardAccel = -(acc.y || 0);
  const h = (typeof headingDeg === "number") ? (headingDeg * Math.PI/180) : null;
  let aN=0, aE=0;
  if (h !== null) { aN = forwardAccel * Math.cos(h); aE = forwardAccel * Math.sin(h); }
  else { aN = forwardAccel; aE = 0; }
  // 静止判定（accがほぼ0なら stationary）
  const accNorm = Math.sqrt((acc.x||0)**2 + (acc.y||0)**2 + (acc.z||0)**2);
  if (accNorm < 0.2) { stationaryCounter++; } else { stationaryCounter = 0; }
  if (stationaryCounter > 5) {
    // 静止なら速度をゼロに寄せる（drift抑制）
    kf.x[2] = 0; kf.x[3] = 0;
  }
  // predict step (注意: x,y表記は east,north => kf uses [n,e,vN,vE])
  // we pass ax=aN (north), ay=aE (east)
  kf.predict(aN, aE, dt);
  // safety: if IMU integrated too long without GPS, reduce cov
  const nowSinceGps = lastGps ? (Date.now()-lastGps.ts) : Infinity;
  if (nowSinceGps > MAX_IMU_INTEGRATION_TIME) {
    // reduce trust in velocity slowly
    kf.P[2][2] += 0.5;
    kf.P[3][3] += 0.5;
  }
}

/* ---------------- GPSハンドラ：GPSが来たら補正（観測ノイズにaccuracyを使用） ---------------- */
function onGpsPosition(pos) {
  const rawLat = pos.coords.latitude, rawLon = pos.coords.longitude;
  const accuracy = pos.coords.accuracy || 30; // meters

  if (!originSet) {
    originLat = rawLat; originLon = rawLon; originSet = true;
  }
  const local = latLonToLocalMeters(rawLat, rawLon); // {x:east, y:north}
  // GPS を観測としてカルマン更新（観測ノイズは accuracy に依存）
  kf.updatePos(local.y, local.x, Math.max(accuracy, 3)); // Rpos = accuracy（下限3m）
  lastGps = { lat: rawLat, lon: rawLon, ts: Date.now(), accuracy };

  // map-matching: スナップを試みる（閾値は観測精度に比例させる）
  const snapThreshold = Math.max(5, Math.min(20, accuracy*1.5));
  const state = kf.getState(); // [n,e,vN,vE]
  const curLatLon = localMetersToLatLon(state[0], state[1]);
  const snapRes = snapToRoad(curLatLon.lat, curLatLon.lon, snapThreshold);
  if (snapRes.snapped) {
    // snap された座標でカルマンを強く修正（位置のみ）
    const snapLocal = latLonToLocalMeters(snapRes.lat, snapRes.lon);
    kf.updatePos(snapLocal.y, snapLocal.x, Math.max(3, accuracy*0.5));
  }

  // 表示更新・スポット判定（local->latlon）
  const usedState = kf.getState();
  const usedLatLon = localMetersToLatLon(usedState[0], usedState[1]);
  checkProximity(usedLatLon.lat, usedLatLon.lon);
}

/* ---------------- スポット判定（表示） ---------------- */
function getDistance(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180) * Math.cos(lat2*Math.PI/180) * Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function checkProximity(lat, lon) {
  if (currentIndex >= spots.length) {
    info.innerText = "すべてのスポットを通過しました。";
    hideAllUI();
    return;
  }
  const spot = spots[currentIndex];
  const distance = getDistance(lat, lon, spot.lat, spot.lon);
  const range = spot.radius || 10;
  info.innerText =
    `現在地: 緯度 ${lat.toFixed(6)}, 経度 ${lon.toFixed(6)}\n` +
    `次のスポット: ${spot.name}（${currentIndex + 1} / ${spots.length}）\n` +
    `残り距離: ${distance.toFixed(1)}m\n` +
    `GPS精度: ${lastGps ? lastGps.accuracy.toFixed(1) + "m" : "―"}\n`;
  if (!hasEnteredSpot && distance < range) showSpot(spot);
}

/* ---------------- スポット表示 / 画像 / 音声（既存ロジックを再利用） ---------------- */
function showSpot(spot) {
  currentSpot = spot; hasEnteredSpot = true; imageIndex = 0;
  audioEl.src = spot.audio[currentPattern];
  image.src = spot.images[imageIndex];
  image.style.display = "block"; nextBtn.style.display = "block"; patternBtn.style.display = "block";
  prevBtn.style.display = spot.images.length > 1 ? "block" : "none";
  nextImgBtn.style.display = spot.images.length > 1 ? "block" : "none";
  audioEl.loop = true; audioEl.play().catch(e=>console.log("自動再生に失敗:", e));
}
function switchPattern(){ const patterns=["A","B","C"]; const i=patterns.indexOf(currentPattern); currentPattern=patterns[(i+1)%patterns.length]; updatePatternButtonText(); if(currentSpot){ audioEl.pause(); audioEl.src=currentSpot.audio[currentPattern]; audioEl.play().catch(e=>{}); } }
function updatePatternButtonText(){ let label=""; switch(currentPattern){case "A":label="English";break;case "B":label="中文";break;case "C":label="日本語";break;} patternBtn.innerText=label; }
function showPrevImage(){ if(!currentSpot) return; imageIndex=(imageIndex-1+currentSpot.images.length)%currentSpot.images.length; image.src=currentSpot.images[imageIndex]; }
function showNextImage(){ if(!currentSpot) return; imageIndex=(imageIndex+1)%currentSpot.images.length; image.src=currentSpot.images[imageIndex]; }
function goToNextSpot(){ audioEl.pause(); currentIndex++; hasEnteredSpot=false; currentSpot=null; hideAllUI(); }
function hideAllUI(){ image.style.display="none"; nextBtn.style.display="none"; patternBtn.style.display="none"; prevBtn.style.display="none"; nextImgBtn.style.display="none"; }

/* ---------------- 位置情報取得 ---------------- */
if ("geolocation" in navigator) {
  const options = { enableHighAccuracy: true, maximumAge: 0, timeout: 15000 };
  navigator.geolocation.watchPosition(
    pos => onGpsPosition(pos),
    err => info.innerText = "位置情報の取得に失敗しました: " + err.message,
    options
  );
} else {
  info.innerText = "このブラウザは位置情報に対応していません。";
}

/* ---------------- 起動処理（ユーザー操作） ---------------- */
startBtn.addEventListener("click", async () => {
  if (userStarted) return;
  userStarted = true;
  startupOverlay.style.display = "none"; startupOverlay.setAttribute("aria-hidden","true");
  try { const AudioCtx = window.AudioContext || window.webkitAudioContext; if (AudioCtx) { const ctx = new AudioCtx(); if (ctx.state === "suspended") await ctx.resume().catch(()=>{}); } } catch(e){}
  try { await enableIMU(); } catch(e){ console.warn("enableIMU failed:", e); }
  // Show first spot UI so user hears audio and calibrates
  try { showSpot(spots[0]); } catch(e){ console.warn(e); }
});

/* ---------------- ユーティリティ: kf時間安全チェック ---------------- */
function kfsafeTime(now) { return true; } // placeholder (保険用)
window.addEventListener("load", ()=>{ updatePatternButtonText(); });
</script>

</body>
</html>
